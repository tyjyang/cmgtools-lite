# name of new variable/collection : definition : regular expression for processes to apply it to
#
vetoMuons : Muon_pt > 10 && Muon_looseId && abs(Muon_eta) < 2.4 && abs(Muon_dz)< 0.2 && abs(Muon_dxybs) < 0.05
# electron cut-based ID Fall17 V2 (0:fail, 1:veto, 2:loose, 3:medium, 4:tight)
vetoElectrons : Electron_pt > 10 && Electron_cutBased > 0 && abs(Electron_eta) < 2.4 && abs(Electron_dxy) < 0.05 && abs(Electron_dz)< 0.2
goodMuons : vetoMuons && Muon_pt > 26 && Muon_mediumId
goodTrigObjs : goodMuonTriggerCandidate(TrigObj_id,TrigObj_pt,TrigObj_l1pt,TrigObj_l2pt,TrigObj_filterBits)
goodMuonsPlus: goodMuons && Muon_charge > 0
goodMuonsMinus: goodMuons && Muon_charge < 0
transverseMass: mt_2(Muon_pt[goodMuons][0],Muon_phi[goodMuons][0],MET_pt,MET_phi)
# Jet_puId = passlooseID * 4 + passmediumID * 2 + passtightID * 1
goodCleanJets : Jet_jetId >= 6 && (Jet_pt > 50 || Jet_puId >= 4) && Jet_pt > 30 && abs(Jet_eta) < 2.4 && cleanJetsFromLeptons(Jet_eta,Jet_phi,Muon_eta[vetoMuons],Muon_phi[vetoMuons],Electron_eta[vetoElectrons],Electron_phi[vetoElectrons])
#
genPrefsrLeps : Numba::prefsrLeptons(GenPart_status, GenPart_statusFlags, GenPart_pdgId, GenPart_genPartIdxMother, GenPart_pt) : W|Z
ptVgen : transversemomentum(GenPart_pt[genPrefsrLeps],GenPart_phi[genPrefsrLeps]) : W|Z
yVgen : rapidity(GenPart_pt[genPrefsrLeps],GenPart_eta[genPrefsrLeps],GenPart_phi[genPrefsrLeps],GenPart_mass[genPrefsrLeps]) : W|Z
mVgen : invariantmass(GenPart_pt[genPrefsrLeps],GenPart_eta[genPrefsrLeps],GenPart_phi[genPrefsrLeps],GenPart_mass[genPrefsrLeps]) : W|Z
#
scetlibWeightsZscalar : Numba::correctN3LL_Z(0,mVgen,yVgen,ptVgen) : W.*|Z.*
scetlibWeightsWPLUSscalar : Numba::correctN3LL_Wp(0,mVgen,yVgen,ptVgen) : W.*plus
scetlibWeightsWMINUSscalar : Numba::correctN3LL_Wm(0,mVgen,yVgen,ptVgen) : W.*minus
